# Chapter 3. 스트림의 새로운 표준 - 리액티브 스트림

## 1. 일반적인 API 문제

RxJavaAPI, CompletableStage, ListenableFuture...

과도한게 많은 선택지는 시스템을 지나치게 복잡하게 만들 수 있다.

예를 들면, 비동기 논블로킹 통신 개념에 의존하지만 서로 다른 API를 갖는 두 라이브러리가 존재하면 하나의 콜백을 다른 콜백으로, 또는 그 반대로 변환하기 위한 유틸리티 클래스를 추가로 제공해야 한다.

위의 예시는 리액티브 프로그래밍의 일반적인 사용에서 나타나는 문제이고, 특이한 상황은 아니다.

- 대부분의 라이브러리,프레임워크는 구성 요소간의 비동기 통신을 위한 자체 인터페이스와 클래스를 제공
- 여기에는 일반적인 요청-응답 통신과 스트림 처리 프레임워크가 포함됨
- 대부분의 경우, 문제를 해결하고 여러 독립 라이브러리를 호환할 수 있게 하기 위해 개발자들이 라이브러리 일부를 수정해 재사용
- 이에 따라 버그 유입될 가능성이 매우 커지며, 유지관리가 필요함

스프링 4.X에서는 ListenableFuture 및 CompletionState 직접적인 통합 제공 X, 

스프링 5.X에서는 ListenableFuture  API가 확장됐으며, 호화성을 높이는 메서드가 추가됨

#### 라이브러리 공급자가 일관된 API를 만들어 낼 수 있는 표준화된 방법이 없다.



## 2. 배압 제어 문제

리액티브 초기 단계에서 데이터 흐름 : 소스에서 구독자에게 푸시하는 방식

 => 풀 방식이 때때로 효율적이지 못해서

예시 : 네트워크 경계를 지닌 시스템에서 다른 네트워크와 통신하는 경우

- 서비스와 데이터베이스간에 비동기 논블로킹 방식사용
  - 서비스에서 데이터베이스로의 요청에 추가시간 소요
  - 서비스 관점에서 전체처리 시간이 대부분 유휴 상태에서 낭비됨
  - 데이터베이스는 미래에 들어올 요청 개수를 알지못해 사전에 데이터 생성할 수 없음
  - 데이터베이스가 응갑을 서비스에 전달하고 서비스가 응답을 처리한 다음, 데이터의 새부분을 요청하는 동안 아무일도 하지않고 대기하므로 비효율적
- 서비스와 데이터베이스간에 비동기 논블로킹 방식사용 + 배치처리 추가
  - 배치 처리를 통해 전체 처리 시간을 단축할 수 있음
  - 처리시간은 여전히 비효율적임
  - 데이터베이스 쿼리하는 동안 클라이언트는 여전히 대기 상태
  - 배치작업은 하나씩 처리하는 것보다 더 오래 걸림
  - 그래도 전체 처리시 효과적 -> 유효성 검사시 첫번째 원소가 만족하면 나머지 항목은 중복작업 건너뜀
- 데이터를 한번 요청, 소스는 데이터를 사용할 수 있게 되면 비동기적으로 푸시
  - 전체적인 처리시간이 최적화가 이루어짐
  - 처리 흐름 동안 서비스가 첫번째 응답을 기다리고 있을 때 대기 상태가 한 번 있음
  - 데이터베이스는 순차적으로 다음 값을 보내기 시작
  - 서비스의 전체 대기 시간에 짧아짐
  - 하지만 데이터베이스는 필요한 수의 원소를 처리한 이후에도 서비스에서 사용하지 않을 항목을 여전히 생성할 수도 있음

푸시 모델을 채택한 가장 중요한 이유 : 요청하는 횟수를 최소화해 전체 처리 시간을 최적화 하는 것

푸시 모델의 기술적 한계 -> 배압의 부재

- 느린 프로듀서와 빠른 컨슈머 : 순수 푸시 모델은 동적으로 시스템 처리량을 증가시키는 것이 불가능
- 빠른 프로듀서와 느린 컨슈머 : 프로듀서 생성 속도 > 컨슈머 처리 속도 => 시스템 부하 => 치명적 오류 발생 가능성 증가
  - 직관적인 솔루션 : 큐에 수집
  - 큐의 종류
    1. 무제한 큐 : 사이즈 제한이 없음. 메시지 전달에 대해 확신할 수 있음, 하지만 리소스가 무제한일 수 없어 메모리 한도에 도달하면 전체 시스템 손상될 가능성이 높음
    2. 크기가 제한된 드롭 큐 : 큐가 가득차면 신규 유입된 메시지 무시하는 형태의 큐. 메시지의 중요성이 낮을 때 사용
    3. 크키가 제한된 블로킹 큐 : 제한에 도달하면 메시지 유입을 차단. 비동기 동작 모두 무효화

적합한 제어를 추가하지 않은 순수한 푸시 모델은 다양한 부작용을 발생 시킬 수 있다.

-> 배압 제어 메커니즘의 중요성

리액티브 라이브러리는 RxJava 1.x와 유사하여 배압을 관리하는 표준화된 기능을 제공하지 않음

- 해결책 : 리액티브 스트림

## 3. 리액티브 스트림 예제

리액티브 스트림에서 기본 인터페이스

- Publisher
- Subscriber
- Subscription
  - 원소 생성 제어하기 위해 기본적인 사항 제공 (unsubscribe, cancel,request)
  - 리액티브 스트림에서는 Publisher와 Subscriber사이의 상호 작용을 확장하기 위해 request 메서드를 도입
    - Subscriber는 request메서드를 통해 Publisher가 보내줘야하는 데이터 크기를 알려줄수 있음
    - 이를 통해 Publisher는 유입되는 원소 개수가 처리할 수 있는 제한을 초과하지 않음
- Processor

리액티브 스트림은 모두 제공

- 동적 푸시-풀 모델
- 푸시모델 : request(Long.MAX_VALUE)
- 풀 모델 : onNext에서 request(1)

## 4. 기술 호환성 문제

리액티브 스트림 기술 호환성 키트(TCK) : 모든 동작을 검증하고 반응 라이브러리를 표준화해 서로 호환하는지 확인하는 공통 도구

- 모든 리액티브 스트림 코드를 방어하고 지정된 규칙에 따라 구현 테스트함

## 5. JDK 9 내부의 리액티브 스트림

- 더그 리는 리액티브 스트림 스펙 첫 릴리즈가 나온 후, JDK 9에 추가하자는 제안함

  - 현재(아마도 JDK 8) 스트림 API가 풀 모델만 제공하고 푸시모델은 누락됨

- 제안 주 목표 : JDK 내부의 리액티브 스트림에 대한 인터페이스를 명확히 하는 것

- 이 개선이 중요한 이유 : 리액티브 스트림이 JDK 표준이기 때문

  

## 6. 반응성 스트림의 고급 개념

리액티브 스트림 스펙 내의 병렬화 개념 = Subscirber의 onNext 메서드를 병렬로 호출하는 것

- 하지만 규칙 중 '스레드 안전성을 보장하는 방식으로 신호를 보내야 하며, 다중스레드에서 수행되는 경우 외부적인  동기화를 사용해야한다.' -> 직렬화되거나 순차적인 onXXX 메서드의 호출을 전제로 함
- 따라서 ParallerPublisher 불가능하며 스트림 요소를 병렬 처리할 수 없음을 뜻함

두 개의 독립적인 스레드 간에 처리를 분할 -> 처리 단계 사이에 비동기 경계 설정

- 서로 독립적으로 작동 -> 전체적인 처리를 병렬로 처리할 수 있음
- 병렬화 달성하기 위해 각 처리 단계를 적절하게 분리 -> 큐 적용

## 7. 리액티브 전망의 강화

JDK 9가 리액티브 스트림 지원 -> 리액티브 스트림의 중요성 깨우침 -> 오픈소스 소프트웨어 업계 선두 주자들이 자사 제품에 채택하기 시작

- RxJava : Observable이 리액티브 스트림 스펙을 준수 할 수 있도록 배압에 대한 지원을 제공,Flowable 제공
- Vert.x, Ratpack : 리액티브 스트림 스펙 채택

리액티브 스트림은 리액티브 라이브러리의 조합 가능성을 크게 증가시킴

호환성 확인 방법 : TCK

- 스프링 프레임워크 : 리액터 프로젝트라는 새로운 리액티브 라이브러리 도입
- 리액터 프로젝트는 새로운 리액티브 스프링 생태계를 위한 기본 요소

## 8. 리액티브 스트림의 실제 작동

